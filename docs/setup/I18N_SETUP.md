# üïäÔ∏è Divine Parsing Oracle - i18n System

## Overview

The Divine Parsing Oracle is a chunked i18n system that provides:
- **Lazy loading** of translation namespaces
- **Automatic string extraction** from code files
- **Performance optimization** through chunked loading
- **Type-safe** translation keys

## Quick Start

### 1. Extract Translation Strings

Run the Divine Parsing Oracle to extract strings from your code:

```bash
npm run i18n:extract
```

This will:
- Scan all `app/`, `components/`, and `lib/` directories
- Extract hardcoded strings
- Generate JSON files in `locales/es/` and `locales/en/`
- Group strings by namespace (page/component)

### 2. Use in Components

```tsx
"use client";

import { useDivineParsing } from "@/components/language/ChunkedLanguageProvider";

export default function MyPage() {
  const { t, language, setLanguage } = useDivineParsing(["common", "dashboard"]);

  return (
    <div>
      <h1>{t("page.title")}</h1>
      <p>{t("page.description")}</p>
      <button onClick={() => setLanguage(language === "es" ? "en" : "es")}>
        {t("switch_language")}
      </button>
    </div>
  );
}
```

### 3. Create Translation Files

Translation files are automatically generated by the oracle, but you can also create them manually:

```json
// locales/es/dashboard.json
{
  "page.title": "Dashboard",
  "page.description": "Panel de control principal",
  "switch_language": "Cambiar idioma"
}
```

```json
// locales/en/dashboard.json
{
  "page.title": "Dashboard",
  "page.description": "Main control panel",
  "switch_language": "Switch language"
}
```

## Architecture

### Chunked Loading

Translations are loaded on-demand by namespace:
- `common` - Always loaded
- `dashboard` - Loaded when dashboard page is accessed
- `quote` - Loaded when quote pages are accessed
- etc.

### Namespace Detection

The oracle automatically detects namespaces from file paths:
- `app/dashboard/page.tsx` ‚Üí `dashboard` namespace
- `components/quote/quote-editor.tsx` ‚Üí `quote` namespace
- `app/clients/page.tsx` ‚Üí `clients` namespace

### Translation Function

The `t()` function supports:
- **Nested keys**: `t("user.profile.name")`
- **Variables**: `t("welcome", { name: "John" })`
- **Fallback chain**: Tries multiple namespaces and languages

## API Reference

### `useDivineParsing(namespaces: string[])`

Hook to access translations in components.

**Parameters:**
- `namespaces`: Array of namespace strings to load

**Returns:**
```typescript
{
  t: (key: string, namespace?: string, variables?: Record<string, any>) => string;
  language: "es" | "en";
  setLanguage: (lang: "es" | "en") => void;
  isLoading: boolean;
  loadedNamespaces: string[];
  invokeOracle: (namespace: string) => Promise<void>;
  invokeOracles: (namespaces: string[]) => Promise<void>;
  getLoadedNamespaces: () => string[];
  isOracleActive: (namespace: string) => boolean;
  error: string | null;
}
```

### `DivineParsingOracleProvider`

Provider component that wraps your app.

```tsx
import { DivineParsingOracleProvider } from "@/components/language/ChunkedLanguageProvider";

export default function RootLayout({ children }) {
  return (
    <DivineParsingOracleProvider initialNamespaces={["common"]}>
      {children}
    </DivineParsingOracleProvider>
  );
}
```

## Best Practices

### 1. Namespace Organization

- Use page-specific namespaces for page content
- Use `common` for shared strings
- Group related strings in the same namespace

### 2. Key Naming

Use dot notation for nested structures:

```json
{
  "page.title": "Page Title",
  "page.description": "Description",
  "form.submit": "Submit",
  "form.cancel": "Cancel"
}
```

### 3. Performance

- Only load namespaces you need
- Use `preinvokeOracles()` for prefetching
- Keep namespaces small and focused

### 4. Variables

Use curly braces for interpolation:

```json
{
  "welcome": "Welcome, {name}!",
  "items_count": "You have {count} items"
}
```

```tsx
t("welcome", { name: "John" });
t("items_count", { count: 5 });
```

## Migration Guide

### From Hardcoded Strings

**Before:**
```tsx
<h1>Dashboard</h1>
<p>Welcome to the dashboard</p>
```

**After:**
```tsx
const { t } = useDivineParsing(["dashboard"]);
<h1>{t("page.title")}</h1>
<p>{t("page.welcome")}</p>
```

### Adding New Translations

1. Run `npm run i18n:extract` to extract strings
2. Review generated JSON files
3. Fill in English translations
4. Use in components with `useDivineParsing()`

## Troubleshooting

### Translations Not Loading

- Check namespace is registered in `ChunkedLanguageProvider`
- Verify JSON file exists in `locales/{lang}/{namespace}.json`
- Check browser console for errors

### Missing Translations

- Run `npm run i18n:extract` to regenerate files
- Check key exists in JSON file
- Verify namespace is loaded in component

### Performance Issues

- Review loaded namespaces per page
- Use `preinvokeOracles()` for prefetching
- Keep translation files small

## Scripts

- `npm run i18n:extract` - Extract strings from code
- `npm run i18n:oracle` - Alias for extract

## Files

- `scripts/divine-parsing-oracle.js` - String extraction tool
- `components/language/ChunkedLanguageProvider.tsx` - Main provider
- `locales/{lang}/{namespace}.json` - Translation files

